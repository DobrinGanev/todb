![todb](https://raw.githubusercontent.com/disordinary/todb/master/docs/logo.png)

An in process node.js document store. This is a work in progress.

This project originialy started as an experiment to create a binary free inverted index for search-index that persisted on disk and did not have to reside in memory.

It is modeled loosely off of level db but with some modifications.

Data is split into tables or collections, when a document is added to the store it's added to an append only log and also cached in memory, when a compaction occurs the data is merged into an SSTable like structure (it's actually a table of JSON objects which have been sorted by id). Indexes are separate files which store data in an inverted index, once again sorted.

The SSTable is inmutable and is replaced entirely, therefore before a compaction takes place events can be rolled back.

This project is a work in progress, some of its messy, some of it doesn't work properly, it's an exeriment at this stage.

##Goals
1. Primary and Secondary indexes. ✓
2. Keys can be larger than memory. ✓ (although this is moot as currently compaction requires an entire table to be stored in memory, it will be fixed. In time.)
3. ACID compliant.
4. Queryable (I'm of two minds here, one part of me wants to build a chainable query system like rethink db, another part of me wants to tackle a propper SQL parser)
5. Joins.
6. Suited to the node ecosystem with streams, evented, etc. Use proxys to
7. Rollbacks.
8. ACID compliance.


##Todo (hopefully in this order):
1. Append only log support ✓
2. Data compaction ✓
3. Indexing (partial)
4. Abstract LevelDown support
5. Streaming
6. Batch processing
7. Streaming merges
8. Splitting files for larger datasets
9. Merging SSTables recursively, similar to a Log Structured Merge Tree.
10. Data querying


Right now it works as follows:

```javascript

//creates a new database directory called testDB, a database is made up of multiple files, one sstable per table, one log per table, and one file per index. During compaction additional temp documents are created.
new DB( 'testDB' , ( err , db ) => {
    //creates a new table called people with a primary key of email, at this stage there is no support for autogenerated PK's like an incremented id, or uuid hash.
    db.createTable("people" , { id : 'email' } ,( err , table) => {
         //we've just created secondary indexes for the name and age fields.
        table.createIndex("name" , ( err ) => {
            //create a new record
            table.put( { id : 'sarah@madeupcompany.com' , name : 'Sarah Smith' , age : 34 } , ( err ) => {
                table.where( 'name' , 'Sarah Smith' , ( err , data ) => {
                    console.log( data );
                } );
             } );
        } );
    });
} );

//that is how it works right now, I'd like to use features like proxies an decorators when they become available so you could have something like:

```javascript
@persistent
class Person {
    constructor( email , name , age ) {
        @primaryKey
        this.email = email;

        @indexed
        this.name = name;

        this.age = age;

        @foreignRelationship(Person)
        this.friends = [ ];
    }
}
```

And treat the object like you would any other in JS, the proxy would mean that the underlying dataset would update with every change.